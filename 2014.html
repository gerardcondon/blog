<!doctype html> 
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" />
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <title>Blog</title>
    <meta content="Personal Blog and Website" name="description" />
    <link rel="alternate" type="application/atom+xml" title="Chess Analysis" href="https://www.gerardcondon.com/feed.xml" /><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script><!-- Latest compiled and minified CSS --><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><!-- Optional theme --><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"><!-- Latest compiled and minified JavaScript --><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link href="stylesheets/all.css" rel="stylesheet" type="text/css" /><script type="text/javascript">
      (function(d,e,j,h,f,c,b){d.GoogleAnalyticsObject=f;d[f]=d[f]||function(){(d[f].q=d[f].q||[]).push(arguments)},d[f].l=1*new Date();c=e.createElement(j),b=e.getElementsByTagName(j)[0];c.async=1;c.src=h;b.parentNode.insertBefore(c,b)})(window,document,"script","//www.google-analytics.com/analytics.js","ga");ga("create","UA-124147465-1", location.hostname);ga("send","pageview");
    </script><script src="javascripts/all.js" type="text/javascript"></script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-static-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button class="navbar-toggle collapsed" data-target="#navbar-ex1-collapse" data-toggle="collapse" type="button"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="https://www.gerardcondon.com">GerardCondon.com</a>
        </div>
        <div class="collapse navbar-collapse" id="navbar-ex1-collapse">
          <ul class="nav navbar-nav">
            <li>
              <a href="/">Home</a>
            </li>
            <li>
              <a href="gaeilge.html">Gaeilge</a>
            </li>
            <li>
              <a href="/music/piano.html">Music</a>
            </li>
            <li>
              <a href="/chess">Chess</a>
            </li>
            <li>
              <a href="pages/links.html">Links</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      <div class="row">
        <div class="col-lg-9 col-md-9"><h3>
  Archive for 2014
</h3>
<ul>
  <h5>
    <a href="2014/12/09/open-plan-offices.html">Open Plan Offices and High Tech Architecture</a>
  </h5>
  <p>Jeremy Paxman recently wrote an <a href="http://www.theguardian.com/commentisfree/2014/sep/12/jeremy-paxman-king-for-a-day-ban-open-plan-offices">article</a> criticising open plan offices. They have been a bugbear of mine for a while also. My working life has been spent in open offices or cubicles (never hot desking thank God) and they&#39;re terrible compared to proper offices. Background noise, air-con issues, lack of privacy and personal space are just some of the issues.</p>
  
  <p>Paxman&#39;s article put me in mind of a TV series which featured a lot of open plan offices. This was the <a href="http://www.bbc.co.uk/programmes/b03vgz7r">Brits who Built the Modern World</a> series on the BBC which detailed the work of the architects such as Norman Foster and Richard Rogers, who were the pioneers of High Tech Architecture. It&#39;s an excellent series and I highly recommend it. The buildings shown typically had a fantastic exterior with really distinctive features. I was really impressed with the level of quality and inventiveness that went into these structures. </p>
  
  <p>However the interiors of these buildings were typically vast open office spaces. The inventiveness that characterized the outsides, had completely vanished when it came to fitting out the inside. Bog-standard, modular office furniture. was the norm. One of the best examples was Norman Foster&#39;s <a href="http://en.wikipedia.org/wiki/Willis_Building_(Ipswich)">Willis Building</a> in Ipswich. This has a stunning exterior of dark glass panels and a rooftop garden, all combined with a soul-destroying, open plan interior.</p>
  
  <p>The really odd thing for me was that the architects really bought into the open office ideals. They truly thought that this was the best way to design a workplace. I would have loved to have seen what they could have done, if they had put the effort in to design proper working spaces which combined private, focused space along with collaborative areas. They thought they were designing workplaces which were more efficient and collaborative, but to my mind all they succeeded in doing was creating an environment where everyone is distracted and disrupted most the time. It&#39;s a real pity and a waste of their talents.</p>
  
  <p><strong>PS</strong> Let&#39;s hope no-one ever interviewing me for a job in an open plan office reads this :)</p>
  
  <p>
    <small><a href="2014/12/09/open-plan-offices.html">→</a> posted on December  9, 2014<span class="tag-item"><small class="label label-default label-tag">development</small></span></small>
  </p>
  <hr />
  <h5>
    <a href="2014/10/02/beginning-backbone-review.html">Book Review: Beginning Backbone by James Sugrue</a>
  </h5><p>My current project at work is a large scale <a href="http://backbonejs.org">Backbone</a> application. The company had no prior experience in web programming before this project and was mainly used to programming in Java. So in order to staff up the project, we needed some way of converting our Java programmers into Backbone programmers.</p>

<p>To do this we looked at the various training materials available on the web. There are a number of excellent resources out there, such as Addy Osmani&#39;s <a href="http://addyosmani.github.io/backbone-fundamentals/">book</a>, the MVC Todo <a href="http://todomvc.com/architecture-examples/backbone/">app</a> and the Backbone <a href="http://backbonejs.org">docs</a> themselves. We wanted to develop a selection of documentation/training materials that we could hand to a new member of the team to get them up to speed.</p>

<p>One of the newer books that we&#39;ve looked at is <a href="http://www.jamessugrue.ie/softwaredev/beginning-backbone-my-first-book">Beginning Backbone</a> by James Sugrue.
<strong>Disclosure:</strong> I&#39;ve previously worked on the same team as James for two years at my current company.</p>

<p><strong>JavaScript and Backbone Introduction</strong></p>

<p>The book begins with a good introduction and overview of Backbone from an architectural point of view and gives examples of companies who have built products on Backbone. I liked this approach, as it&#39;s one thing explaining why you should use Backbone from a coding perspective but it&#39;s also nice to be able to justify the choice from a risk perspective to management. Having concrete examples of successful companies helps us make that case.</p>

<p>There is a chapter on JavaScript which is probably obligatory in a book like this. It&#39;s fine as an introduction to the language, but you would need to combine this with something specifically for JavaScript like <a href="http://eloquentjavascript.net">&quot;Eloquent JavaScript&quot;</a> or <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">&quot;JavaScript: The Good Parts&quot;</a>.</p>

<p>Each of the components of Backbone is dealt with comprehensively. The models, collections, views, events and router are explained with plenty of examples. Templating described alongside the views using both <a href="http://handlebarsjs.com">Handlebars</a> and <a href="http://mustache.github.io">Mustache</a>.</p>

<p>After the introduction we get a walkthrough of how to create an application. The application is surprisingly comprehensive. It&#39;s a Twitter clone and not the standard todo app. It deals with linking models to views, reusing views,  and how to tie it together with events.</p>

<p><strong>Backbone EcoSystem</strong></p>

<p>From there the book branches out to cover the wider Backbone ecosystem. Backbone is not an all encompassing framework. In fact it quite a simple framework with a lot of scope for customisation. It is a foundation upon which you will layer many plugins and libraries, and so understanding what additional addons are available and how to use them is vital to getting the most out of Backbone.</p>

<p>The book covers</p>

<ul>
<li>UI considerations such as two way data binding using <a href="http://nytimes.github.io/backbone.stickit/">Stickit</a>, layout management using <a href="https://github.com/tbranyen/backbone.layoutmanager/wiki">LayoutManager</a> and more.</li>
<li>Model concerns such as <a href="https://github.com/fantactuka/backbone-validator">validations</a>, <a href="https://github.com/tommyh/backbone-view-model">view-models</a>, <a href="https://github.com/derickbailey/backbone.memento">undo-redo</a> and others.</li>
</ul>

<p>We had started coding well before the book was written and a lot of the choices we had made on Backbone plugins are mentioned in the book. It was nice to get some validation of those choices. In addition reading this section of the book prompted us to look at introducing view models to our code.</p>

<p>One of the problems we had was that it&#39;s easy to see how a simple todo application can be built from Backbone, but it&#39;s harder to extrapolate from there and design how a larger application should hang together. We encountered problems at scale e.g. managing views and their resources when having high double digit numbers of views and templates. The book introduces two plugins - <a href="http://marionettejs.com">Marionette</a> and <a href="http://thoraxjs.org">Thorax</a> - which extend Backbone to give more comprehensive view management. Even if the specific plugins described in the book are not for you, at least you will be made aware of the issues that await in the future.</p>

<p>As an aside, it is here that the book encounters one of the curses of JavaScript programming - the choice of two equally plausible alternatives! This has been the bane of my life for the past couple of years. For every situation that you come across, there will be two equally valid options. You will have to make a choice between them but you won&#39;t have enough information at the time to understand their pros and cons. Murphy&#39;s law dictates that of course you will pick the wrong one! You have to choose and second guess yourself for the rest of the project!</p>

<p>The specific JavaScript cases in the book are Marionette/Thorax and QUnit/Jasmine. This isn&#39;t just limited to JavaScript. For example, in Rails you have the choice between the omakase and prime <a href="http://words.steveklabnik.com/rails-has-two-default-stacks">stacks</a>. It&#39;s beyond the scope of the book to give definitive answers on which to choose. You need to evaluate the options based on your own situation but I think the book gives a good enough head start.</p>

<p><strong>Building a JavaScript application - TDD, Build Systems</strong></p>

<p>The book is not just about beginning Backbone programming. It is much more than that. It gives you a solid base from which to start developing JavaScript applications. Topics such as testing and automation, building, code management are dealt with.
The benefits of TDD are explained along with an introduction to two of the most popular JavaScript TDD frameworks - <a href="http://qunitjs.com">QUnit</a> and <a href="http://jasmine.github.io">Jasmine</a>.</p>

<p>The book also has a chapter on best practices &amp; design patterns. The emphasis is not just about using Backbone but using it well. It covers user visible features such as performance and memory leaks as well as development concerns such as creating and maintaining a manageable code base. For example, JavaScript modularity is not straightforward. The JavaScript language does not provide for a way for files to include other files. As a programmer you definitely want to split your codebase into separate files and then compile them together for the released product. The book uses <a href="http://requirejs.org">RequireJS</a> to show you how to do this.</p>

<p><strong>Negatives</strong></p>

<p>The formatting of the code samples is off in quite a few places. The indentation is out and there are some spaces missing turning <code>var myarray</code> into <code>varmyarray</code>. These are more than just code formatting errors - these would lead to compile errors in the code. There is a Github <a href="https://github.com/jamessugrue/beginning-backbone">repository</a> of the code samples in the book though, which partially makes up for this.</p>

<p>From a personal perspective, I don&#39;t like the <a href="http://gruntjs.com">Grunt</a> approach to build management so I wasn&#39;t too keen on the whole chapter devoted to this. We tried Grunt on our project at work and found that as as the number of build steps increases, the json required to configure Grunt becomes more and more complex. I prefer using code over configuration files as then I have a chance to debug the build process, insert print statements etc. I think there must be better tools out there. Stepping away from JavaScript and using Ruby, there is <a href="https://rubygems.org/gems/rake">Rake</a>, which is what we use on our project. If you are using Rails then you have the Asset Pipeline approach. I found that Grunt was hard to debug and it was not easy to figure out what went wrong for some step in the middle.</p>

<p><strong>Summary</strong></p>

<p>Overall I would recommend this book. I think its invaluable for ramping up new developers to a Backbone project.  Also from an experienced programmer&#39;s perspective, it is an easy and quick way to gain a broad understanding of the Backbone landscape. It introduces a number of topics, not just Backbone, but also JavaScript development in general. The book promotes a professional and structured approach to software development, making it suitable for a team who are beginning web development and want to get their process set up correctly.</p>

  <p>
    <small><a href="2014/10/02/beginning-backbone-review.html">→</a> posted on October  2, 2014</small>
  </p>
  <hr />
  <h5>
    <a href="2014/09/19/working-with-typescript.html">Working With Typescript</a>
  </h5><p>For the past year and a half, my team at work have been using <a href="http://www.typescriptlang.com">TypeScript</a> to implement a large single page application in <a href="http://www.backbonejs.org">Backbone</a>. We&#39;re over three quarters of the way through the project, closing in our our first release and here are my thoughts on using TypeScript to date.</p>

<p>This is my first major foray into web development, so it also required ramping up on HTML, CSS and REST. Previously I had used JavaScript to implement the client side of a websocket API, but that project was non-GUI work.</p>

<p><strong>Reasons for choosing TypeScript</strong></p>

<p>The company has settled on TypeScript for web programming due to a number of factors.</p>

<ul>
<li><p>Firstly is the additional security/peace of mind provided by type checking. For example, this prevents a lot of mistakes in calling functions with the wrong parameters. It makes some refactorings easier, as the compiler can tell you when you&#39;re calling functions that no longer exist or are passing the wrong types to a function.</p></li>
<li><p>TypeScript adds classical Object-Oriented constructs to JavaScript e.g. interfaces, classes with inheritance. Rather than having to chose a library to implement inheritance, it is instead a first class language feature. I find this, along with having a proper super keyword to be much more usable in practice than prototypical inheritance. </p></li>
</ul>

<p>A nice feature is that TypeScript has support for implicit interfaces. The compiler will figure out if a class implements an interface rather than requiring that the class declares a list of implements X clauses in its definition. This reduces the friction of dealing with the type system.</p>

<ul>
<li><p>TypeScript is compatible with JavaScript so any library out there can be used with our code with no problems.</p></li>
<li><p>Better tooling. The idea behind this was that, given that TypeScript has a proper type system, this would allow better tooling such as Intellisense. The theory was that programming in TypeScript would be a better experience because the IDE would be better.</p></li>
</ul>

<p>As an aside, I would question the value of Intellisense and the type of code it leads to. Take Java for example. When you combine Intellisense with modern IDEs&#39; ability to automatically import files, you greatly lower the barrier to coupling. It is no problem to include remote files, grab the inevitable Singleton instance, and execute large Law of Demeter busting method chains on them. </p>
<div class="highlight"><pre class="highlight plaintext"><code>    GlobalSingletonReference.getInstance().getSomethingElse().andItsChild()
        .lawOfWhatExactlyNow().pleaseStopSoon().noTheresMore().invoke()
</code></pre></div>
<p>I think Java tools have given the ability to create larger programs than can be properly maintained.</p>

<p>These features were seen as key to creating a more maintainable source code base especially at large scale.</p>

<p><strong>My Experience with TypeScript</strong></p>

<p>We had written a JavaScript prototype in Backbone and we ported that to TypeScript, so that we could compare and see how it went. I tried to use TypeScript as much as possible to be fair to the experiment. You can get away with basically writing JavaScript and passing it through the TypeScript compiler but that&#39;s no good to anyone really.</p>

<p>I found it made my code look more like Java or C#. This was especially the case with class definitions. Defining a class hierarchy in JavaScript is terrible - needing to set the prototype to the parent&#39;s prototype, manually defining super etc. The TypeScript version is very familiar to a Java or C# coder. Our group of TypeScript programmers were converted Java/C++ programmers so this was a huge bonus.</p>

<p>Having interfaces was great. They&#39;re very useful in defining APIs and especially so for documenting external APIs. One thing I hate about JavaScript, is having to read documentation or readme files for third party libraries in order to find out their API. An interface definition in the language itself is far superior, as it is a lot more concise and guaranteed to be correct, having gone through the compiler.</p>

<p>In the end, the code had the same classes with the same class names but the class implementations were far more readable due to the OO nature of TypeScript and the ability to define and program to interfaces.</p>

<p>I did find that refactoring was easier - operations like adding additional parameters to functions were trivial compared to JavaScript. For the JavaScript code, I had to rely on my unit tests to assure me that my refactorings were correct but here I could offload a lot of those tests to the compiler.</p>

<p>When we started on TypeScript it was version 0.8. The compiler was a bit rough then and crashed on some invalid input rather than reporting errors. It has been steadily improved since then and version 1.0 is perfectly fine for us, reporting the correct errors for all the previously crashing cases. Also the language has been added to and improved over time.</p>

<p><strong>Things I didn&#39;t like about TypeScript</strong></p>

<p>On the flip side there are a lot of things that I don&#39;t really like about TypeScript.
Some features of JavaScript e.g. different return types, can&#39;t be represented in TypeScript. In these circumstances you find yourself using the &quot;any&quot; type - the equivalent of using Object in Java. The problem with this is that using it completely circumvents the type checker. Thus the more complex code ends up being the code with less type checking. </p>

<p>Other JavaScript features such as mixins have such horrible syntax in TypeScript (see <a href="https://typescript.codeplex.com/wikipage?title=Mixins%20in%20TypeScript">here</a>) that they&#39;re basically unusable. Mixins in particular require repeated boilerplate code to get past the compiler. That was a pattern with a lot of the issues I had with TypeScript. As you try to do the more dynamic JavaScript stuff, you end up writing and repeating declarations to get the compiler off your back. Ideally there would be some way to say to the TypeScript compiler that we are going to implement this interface dynamically - the implementation may not be here now but it will be at runtime. We ended up generating a lot of this boilerplate code using Ruby and Erb (a topic for another blog post).</p>

<p>I tried debugging with source maps in Chrome but I wasn&#39;t a fan of the experience. Breakpoints would always get shifted a few lines and it was hard to get them to break on a function. I was constantly wondering if I had the correct version rather than a cached sourcemap and did the TypeScript match up to the JavaScript. I ended up just using the compiled JavaScript for debugging.</p>

<p>Continuing with the last point, with some TypeScript features, you need to know what type of code was generated e.g. did a variable assignment get generated in the constructor or on the prototype. For example, this is necessary when integrating with Backbone. Instance variables in TypeScript are not defined on the prototype but instead in the constructor after the call to super. This means that they are not defined by the time the Backbone constructor is called. The Microsoft <a href="https://github.com/Microsoft/TypeScriptSamples/blob/master/todomvc/js/todos.ts">solution</a> is to put the call to super in the middle of the constructor but this looks wrong to any Java programmer and I could see them inadvertently breaking the code by moving super to the top of the constructor. </p>

<p>TypeScript&#39;s support for Generics was almost good but again there are some issues. The main one I ran into is that you can&#39;t create a new instance of the generic type e.g. for a generic type T you can&#39;t do <code>var x = new T()</code>. There are ways around this by passing in functions that create objects but the code they lead to is fairly bad.</p>

<p>The idea that types would lead to better tooling didn&#39;t pan out for us. Taking IDEs first, I think the main tool that supports TypeScript is <a href="http://msdn.microsoft.com/en-us/vstudio/aa718325.aspx">Visual Studio</a>. There is also JetBrains&#39; <a href="http://www.jetbrains.com/webstorm/">WebStorm</a>. As IDEs go these seem perfectly fine. It&#39;s a bit hard for me to evaluate this as I&#39;m not a fan of large IDEs. One issue with these is that, especially in the case of Visual Studio, they require large license fees. I don&#39;t like criticising tools on cost issues, as I feel that companies should treat these as a required cost of hiring programmers. Unfortunately, a lot of companies don&#39;t, so if I&#39;m required to buy a personal license, I much prefer to buy a license for a tool like <a href="http://www.sublimetext.com">Sublime Text</a>. </p>

<p>TypeScript files import other files by means of a reference path at the top of the file. This is almost like Java except unfortunately the compiler does not enforce these, thus requiring them to be manually maintained. This is impossible to get right for a large project. The only essential ones are those for your base classes but if you leave out the others then IDEs have problems locating type declarations. If you have extraneous references that are not technically needed then this can lead to the TypeScript compiler generating invalid code that defines subclasses before their parent classes. When run, these cause runtime exceptions. Not a great situation.</p>

<p>There aren&#39;t a great number of TypeScript plugins for Sublime Text and there is no official one from Microsoft. Also there are no code quality tools such as linters. It&#39;s not much use running the JavaScript versions as the only thing they can run on is the compiled code. The set of tools available for JavaScript is much larger and more mature. Even where you would think that having types would allow for newer tools e.g. static analysis or dependency graph generators, there is nothing.</p>

<p>From a language point of view I wonder if trying to make all valid JavaScript code be valid TypeScript code is harming them? Would they be better going for a more C# like language and mandating that any JavaScript should be in separate files? That&#39;s what we ended up doing anyway - we didn&#39;t want to mix our JavaScript and TypeScript codebase.</p>

<p><strong>Integration with Third Party Code.</strong></p>

<p>In order to use external JavaScript files in TypeScript, you must first create a definition file for the JavaScript API. This declares, in a manner similar to Java interfaces, the functions, classes and interfaces that the JavaScript code exposes. These files can be a pain to locate and maintain. There is a Github repository <a href="https://github.com/borisyankov/DefinitelyTyped">Definitely Typed</a> which maintains a collection of .d.ts files for popular JavaScript libraries. These are typically of a high standard but we have had to add missing functions to some Backbone .d.ts files. If there is none online you have to write one yourself which can involve reverse engineering the API and types of the library.</p>

<p>I think there is a large risk in using these, given that they are neither maintained by the library owners in question or by Microsoft themselves. It is problematic to update the libraries as now you have to also update the .d.ts. files. Everything going well, the Definitely Typed version will be updated to the latest version but there are no guarantees. What happens if the maintainer of this repository gets fed up and stops updating the files?</p>

<p>However once they are found, these .d.ts files can be extremely useful. When working with websockets, the TypeScript lib.d.ts file was the best documentation I found on the subject. I think the interface/protocol concept is a great addition to any programming language. It is especially useful for documenting APIs and it harms Ruby and JavaScript not to have such a construct.</p>

<p>It can be a bit tricky to integrate your TypeScript code with existing JavaScript libraries. As outlined above with Backbone, some libraries need to have code that&#39;s on the prototype so you need to know the code that TypeScript generates. Also where in the hierarchy does the library go? We found it best to have the JavaScript classes at the top of the inheritance tree and TypeScript in the subclasses.</p>

<p><strong>Conclusions</strong></p>

<p>One issue I&#39;d have with TypeScript is trying to gauge Microsoft&#39;s commitment to the language. Are they really in this for the long term? For example, the code samples on their website haven&#39;t been updated in ages. Also how large can the TypeScript community get? Are there really going to be a critical mass of developers abandoning JavaScript for this - especially considering Microsoft&#39;s past attitude to the web and Internet Explorer. The amount of bridges they must have burned is quite large at this stage. If I&#39;d suffered for years working around IE6&#39;s issues, the last thing I&#39;d do is switch to Microsoft&#39;s new web language.</p>

<p>Overall though, I think it was worthwhile for the company to use TypeScript. The pros outweigh the cons, especially once you identify the issues with TypeScript and develop coding standards to avoid them. As a developer I would have preferred CoffeeScript as a JavaScript replacement but I can see how it would be easier to shift Java developers over to TypeScript. I think its given them a lot of security that they wouldn&#39;t have had with JavaScript.</p>

  <p>
    <small><a href="2014/09/19/working-with-typescript.html">→</a> posted on September 19, 2014<span class="tag-item"><small class="label label-default label-tag">development</small></span></small>
  </p>
  <hr />
</ul>
        </div>
        <div class="col-lg-3 col-md-3">
          <div class="well">
            <h4>
              Tags
            </h4>
            <ul class="list-unstyled">
              <li>
                <a href="tags/microposts.html">microposts</a> (24)
              </li>
              <li>
                <a href="tags/octopress.html">octopress</a> (4)
              </li>
              <li>
                <a href="tags/gaming.html">gaming</a> (3)
              </li>
              <li>
                <a href="tags/development.html">development</a> (46)
              </li>
              <li>
                <a href="tags/apple.html">apple</a> (3)
              </li>
              <li>
                <a href="tags/heroku.html">heroku</a> (2)
              </li>
              <li>
                <a href="tags/business.html">business</a> (1)
              </li>
              <li>
                <a href="tags/chess.html">chess</a> (2)
              </li>
              <li>
                <a href="tags/games.html">games</a> (2)
              </li>
              <li>
                <a href="tags/gaeilge.html">gaeilge</a> (2)
              </li>
              <li>
                <a href="tags/music.html">music</a> (2)
              </li>
              <li>
                <a href="tags/architecture.html">architecture</a> (1)
              </li>
              <li>
                <a href="tags/tech.html">tech</a> (1)
              </li>
              <li>
                <a href="tags/javascript.html">javaScript</a> (1)
              </li>
              <li>
                <a href="tags/fortnite.html">fortnite</a> (1)
              </li>
              <li>
                <a href="tags/gaeilge.html">Gaeilge</a> (1)
              </li>
              <li>
                <a href="tags/projects.html">projects</a> (1)
              </li>
            </ul>
          </div>
          <div class="well">
            <h4>
              By year
            </h4>
            <ol>
              <li>
                <a href="2020.html">2020</a> (14)
              </li>
              <li>
                <a href="2019.html">2019</a> (17)
              </li>
              <li>
                <a href="2018.html">2018</a> (2)
              </li>
              <li>
                <a href="2017.html">2017</a> (11)
              </li>
              <li>
                <a href="2016.html">2016</a> (3)
              </li>
              <li>
                <a href="2015.html">2015</a> (6)
              </li>
              <li>
                <a href="2014.html">2014</a> (3)
              </li>
              <li>
                <a href="2013.html">2013</a> (11)
              </li>
              <li>
                <a href="2012.html">2012</a> (25)
              </li>
            </ol>
          </div>
          <div class="well">
            <h4>
              Links
            </h4>
            <ul class="list-unstyled">
              <li>
                <a href="http://www.gerardcondon.com">Gerard Condon</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>